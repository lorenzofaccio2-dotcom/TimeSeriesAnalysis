library(odbc)
library(DBI)
library(tidyverse)
library(zoo)
library(forecast)
library(tseries)
library(DescTools)

# Connessione al DB
con <- dbConnect(
  odbc(),
  Driver   = Sys.getenv("DB_DRIVER"),
  Server   = Sys.getenv("DB_SERVER"),
  Database = Sys.getenv("DB_DATABASE"),
  Trusted_Connection = Sys.getenv("DB_TRUSTED")
)


# Lettura dati
df = dbGetQuery(con, 'SELECT * FROM dbo.SerieStorica')
print(colnames(df))

# Pulizia e aggregazione vendite per store e giorno
df = df %>%
  arrange(DataVendita) %>%
  mutate(DataVendita = as.Date(DataVendita)) %>%
  group_by(PuntoVendita, DataVendita) %>%
  summarise(Vendite = sum(Vendite, na.rm = TRUE), .groups = "drop") %>%
  ungroup()

q <- quantile(df$Vendite, probs = c(0.05, 0.95), na.rm = TRUE)


df$Vendite <- pmin(pmax(df$Vendite, q[1]), q[2])


# Grafico vendite giornaliere per store
ggplot(df, aes(x = DataVendita, y = Vendite, col = factor(PuntoVendita))) +
  geom_line() +
  labs(title = "Vendite giornaliere per store", x = "Data", y = "Vendite", col = "PuntoVendita") +
  theme_minimal()

# Analisi per uno store
store = df %>% filter(PuntoVendita == 1)
y = zoo(store$Vendite, order.by = store$DataVendita)

acf(y)
pacf(y)
adf.test(y)
kpss.test(y)

# Modelli ARIMA di baseline
ordini = list(c(1,0,0), c(2,0,0), c(1,1,0))
fit_list = lapply(ordini, function(o) Arima(y, order = o))
best_arima = Arima(y, order = c(2,0,0))
fcast_ar = forecast(best_arima, h = 365)
autoplot(fcast_ar)

# ARIMA stagionale log
seasonal_arima = Arima(log(y + 1), order = c(2,0,0), seasonal = list(order = c(1,0,0), period = 50))
fcast_seasonal = forecast(seasonal_arima, h = 28)
autoplot(fcast_seasonal)
summary(seasonal_arima)

# Modello ETS
ets_fit = ets(y)
fcast_ets = forecast(ets_fit, h = 28)
autoplot(fcast_ets)
summary(ets_fit)

# Auto ARIMA
auto_fit = auto.arima(y, seasonal = TRUE)
fcast_auto = forecast(auto_fit, h = 28)
autoplot(fcast_auto)
summary(auto_fit)

# STL + ETS
y_ts = ts(y, frequency = 365)
stl_fit = stlf(y_ts, s.window = "periodic", h = 28)
summary(stl_fit)
autoplot(stl_fit)

# TSLM con trend e stagionalit√† annuale
y_ts_log = ts(log(y), frequency = 365)
lm_fit = tslm(y_ts_log ~ trend + season)
fcast_lm = forecast(lm_fit, h = 28)
autoplot(fcast_lm)
summary(lm_fit)

# Confronto forecast su uno store in un unico grafico
forecast_df = tibble(
  Data = tail(store$DataVendita, 28),
  ARIMA = as.numeric(fcast_ar$mean[1:28]),
  Seasonal_ARIMA = as.numeric(fcast_seasonal$mean),
  ETS = as.numeric(fcast_ets$mean),
  Auto_ARIMA = as.numeric(fcast_auto$mean),
  STL_ETS = as.numeric(stl_fit$mean),
  TSLM = as.numeric(fcast_lm$mean)
)



# Aggiungi la serie osservata
forecast_df$Osservato <- tail(store$Vendite, 28)

forecast_df_long <- forecast_df %>%
  pivot_longer(-Data, names_to = "Modello", values_to = "Vendite")

# Plot con ggplot
ggplot(forecast_df_long, aes(x = Data, y = Vendite, color = Modello)) +
  geom_line(size = 1) +
  labs(title = "Confronto forecast store 1", x = "Data", y = "Vendite") +
  theme_minimal()

print(forecast_df_long, n =180)

